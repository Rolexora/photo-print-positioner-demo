<!DOCTYPE html><html lang="hu">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Photo Print Positioner (PPP)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    input, button, select { margin: 5px; }
    canvas { border: 1px solid #ccc; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Photo Print Positioner (PPP)</h1><input type="file" id="images" multiple><br> <label>Papírméret: <select id="paperSize"> <option value="90x130">9x13 cm</option> <option value="100x150">10x15 cm</option> <option value="110x170">11x17 cm</option> <option value="130x180">13x18 cm</option> <option value="210x297">A4</option> <option value="297x420">A3</option> </select> </label><br> <label>Képek közötti elválasztó: <input type="checkbox" id="separator"></label><br> <label>Forgatás engedélyezése: <input type="checkbox" id="rotate" checked></label><br> <label>Formátum: <select id="format"> <option value="pdf">PDF</option> <option value="jpeg">JPEG</option> <option value="png">PNG</option> </select> </label><br> <button onclick="generatePreview()">Előnézet</button> <button onclick="generateOutput()">Letöltés</button>

<canvas id="previewCanvas" width="600" height="850"></canvas>

  <script src="https://cdn.jsdelivr.net/gh/mariowise/2d-guillotine-cutter/cutter.js"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>  <script>
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');

    async function generatePreview() {
      const paper = document.getElementById('paperSize').value.split('x');
      const rotate = document.getElementById('rotate').checked;
      const separator = document.getElementById('separator').checked ? 1 : 0;

      const paperW = parseInt(paper[0]);
      const paperH = parseInt(paper[1]);

      const files = document.getElementById('images').files;
      const images = await Promise.all([...files].map(file => loadImage(file)));

      const items = images.map(img => ({
        width: img.width / 10,
        height: img.height / 10,
        img: img,
        id: Math.random().toString(36).substring(7)
      }));

      const packer = new GuillotineBinPack(paperW, paperH, false, 'shorter_side', 'best_area');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      items.forEach(item => {
        const node = packer.insert(item.width + separator, item.height + separator, rotate);
        if (node.width) {
          ctx.drawImage(
            item.img,
            node.x * 3,
            node.y * 3,
            node.width * 3 - separator * 3,
            node.height * 3 - separator * 3
          );
        }
      });
    }

    async function generateOutput() {
      const format = document.getElementById('format').value;
      const paper = document.getElementById('paperSize').value.split('x');
      const rotate = document.getElementById('rotate').checked;
      const separator = document.getElementById('separator').checked ? 1 : 0;

      const paperW = parseInt(paper[0]);
      const paperH = parseInt(paper[1]);

      const files = document.getElementById('images').files;
      const images = await Promise.all([...files].map(file => loadImage(file)));

      const items = images.map(img => ({
        width: img.width / 10,
        height: img.height / 10,
        img: img,
        id: Math.random().toString(36).substring(7)
      }));

      const packer = new GuillotineBinPack(paperW, paperH, false, 'shorter_side', 'best_area');

      const canvasOut = document.createElement('canvas');
      canvasOut.width = paperW * 3;
      canvasOut.height = paperH * 3;
      const ctxOut = canvasOut.getContext('2d');

      items.forEach(item => {
        const node = packer.insert(item.width + separator, item.height + separator, rotate);
        if (node.width) {
          ctxOut.drawImage(
            item.img,
            node.x * 3,
            node.y * 3,
            node.width * 3 - separator * 3,
            node.height * 3 - separator * 3
          );
        }
      });

      if (format === 'pdf') {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'mm', format: [paperW, paperH] });
        pdf.addImage(canvasOut.toDataURL('image/jpeg'), 'JPEG', 0, 0, paperW, paperH);
        pdf.save('photo_output.pdf');
      } else {
        const link = document.createElement('a');
        link.download = `photo_output.${format}`;
        link.href = canvasOut.toDataURL(`image/${format}`);
        link.click();
      }
    }

    function loadImage(file) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = URL.createObjectURL(file);
      });
    }
  </script></body>
</html>
